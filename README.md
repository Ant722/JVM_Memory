   #  JVM.организация памяти, сборщики мусора, VisualVM.
   
   ### ClassLoader

1. **JVM** проверяет уникальность классов. Загрузчик классов подгружает класс _JvmComprehension_ и пакеты указанные в _pom.xml(Memory)_(_package org.example_).
2. Подгрузка(_loading_) : 
   1. **Application**(приложение) **ClassLoader**  делегирует запрос **Platform**(в других источниках **_Extension_** - расширение) **ClassLoader**.
   2. **Platform ClassLoader** дальше передает запрос **Bootstrap**(загрузчик) **ClassLoader**.
   3. **Bootstrap ClassLoader** ищет в пути своем classpath, чтобы проверить, доступен класс или нет. Если класс доступен, он загружается, иначе запрос возвращается **Platform ClassLoader**.
   4. **Platform ClassLoader** проверяет класс в **Platform** classpath. Если класс доступен, он загружается, иначе запрос передается в **Application ClassLoader**.
   5. **Application ClassLoader** ищет класс в пути к классам приложения. Если класс доступен, то загружается, иначе вы увидите исключение _ClassNotFoundException_.
3. Связывание(_linking_):
   1. **Verify** проверка на валидность кода.
   2. **Prepare** подготовка примитивов в статических полях.(в нашем случае отсутствуют статические поля.Размещаются в памяти JVM)
   3. **Resolve** связывание ссылок на другие классы.
4. Инициализация, выполняются инициализаторы _static_.
5. Загружаются все данные о классе и константы в ***MetaSpace***.


   ### Организация памяти

1. В момент вызова метода *main* в стековой памяти создается фрейм(рабочий стол), в рамках которого данный поток работает с переменными и операндами.
2. В этом рабочем пространстве памяти (выделленом под main фрейме) выделяется место под ***int i***.
3. На 7 строке под *new Object* в куче (динамически распределяемая область оператитвной памяти,иначе *heap*(создается при старте JVM)) 
   выделяется соответствующий обьем памяти. А под ссылку ***o*** на этот обьект выделяется место в фрейме *main*.
4. 8 строка, обьявляем *Integer ii*, выделяется память в куче и создается ссылка в фрейме *main*.
5. 9 строка:
   1. Выделяется место в стеке под фрейм метода **printAll**. 
   2. В данном фрейме создаются ссылки на используемые обьекты (***o***, ***ii***).
   3. Выделяется память под примитив ***i***.
6. Дальше программа переходит к коду метода **printAll**.Строка 14, выделяется место в куче под переменную **uselessVar**,а в фрейме этого метода размещается ссылка на нее.
7. Строка 15: 
   1. Создаётся новый фрейм в стеке под **System.out**.
   2. В куче выделяется место под строку образованную в методе **println(o.toString() + i + ii)**.
   3. В фрейме размещаются ссылка на строку ***o.toString()*** и обьект ***ii***, примитив ***i***.
   4. Когда метод завершает выполнение, блок памяти (frame), отведенный для его нужд, очищается, и пространство становится доступным для следующего метода. 
   5. По окончании метода **printAll**,блок памяти в стеке, отведенный для его нужд, очищается.
   6. Сборщик мусора определяет какие обьекты стали потерянными(утратили все ссылки и болше не используются) и удаляет из кучи ***o.toString(), ii , uselessVar***
8. JVM переходит к строке 10  :
   1. Создаётся новый фрейм в стеке под новый **System.out**.
   2. В куче выделяется место под строку образованную в методе **println(_"finished"_)**.
   3. В фрейме размещается ссылка на строку _"finished"_.
   4. Когда метод завершает выполнение, фрейм, отведенный для его нужд, очищается.
9. По завершению *main* стековая память очищается. В куче при этом все обьекты сохраняются не смотря на удаление всех ссылок.
10. Сборщик мусора по окончании программы очищает кучу.


   ### Управление памятью JVM. Сборка мусора.

1. Разметка: сначала сборщик определяет, какие объекты используются, а какие нет. Те, что используются или доступны для стековых указателей, рекурсивно помечаются как живые.
2. Удаление: сборщик проходит по куче и убирает все объекты, которые не помечены как живые. Эти места в памяти помечаются как свободные.
3. Сжатие: после удаления неиспользуемых объектов все выжившие объекты перемещают, чтобы они были вместе. Это уменьшает фрагментацию и повышает скорость выделения памяти для новых объектов.



